:mod:`components`
=================

.. py:module:: components


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   base_component/index.rst
   bin_conv_unit/index.rst
   bin_max_pool_unit/index.rst
   bn_rom/index.rst
   buffer_layer/index.rst
   conv_layer/index.rst
   conv_unit/index.rst
   fixed_point_multiplier/index.rst
   kernel_rom/index.rst
   max_pool_layer/index.rst
   max_pool_unit/index.rst
   multi_channel_conv_unit/index.rst
   network_parser/index.rst
   tri_scatter_unit/index.rst
   utils/index.rst


Package Contents
----------------


.. py:class:: BaseComponent(layer_id=0, channel_id=0, unit_id=0, convert='')

   This class serves as template to build the components in vhdl. The methods
   rtl and get_signal are obrigated to be implemented. The rtl method should
   implement a method with @block decorator describeing the desired the logic.

   The get_signals method returns the input and output signals gather in a
   dict. The convert method call get_signals and rtl methods to generate the
   vhdl files. Each class builded in BaseComponent have identifiers to layer,
   desired channel input and which unit inside the superior abstraction.

   :param layer_id: layer index
   :type layer_id: int
   :param unit_id: index of the unit inside a layer
   :type unit_id: int
   :param channel_id: index of the channel input inside a unit
   :type channel_id: int

   .. method:: rtl(self)
      :abstractmethod:



   .. method:: get_signals(self)
      :abstractmethod:



   .. method:: convert(self, name='', path='')


      This function convert the logic implemented in the rtl method in a vhdl
      file. The signal widths can be foun in the rtl method description.

      :param name: A string with the name file to vhdl file generated and         the name to the VHDL entity.
      :type name: str
      :param path: A string with the path where the output file will be         writed.
      :type path: str



.. py:class:: BnROM(mean_file='yolov3_tiny/yolov3_tiny_mean.h', scale_file='yolov3_tiny/yolov3_tiny_scale.h', variance_file='yolov3_tiny/yolov3_tiny_variance.h', bias_file='yolov3_tiny/yolov3_tiny_biases.h', path='/home/welberthime/Documentos/nios-darknet/include', **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class implements some functions to read the weights file and generate
   a ROM with the values identifyied by the layer_id, channel_id and unit_id.
   The clock signal serves only to give a signal to the sensitive list of the
   process, registers should not be generated.

   Both path to weights and data arrays about the weight organizations should
   be informed or implemented. The data to tiny_yolov3 first layer weights is
   informed in the __init__ method. To generate the kernel ROMs, this class
   provides some methods to read the weights, convert them to binary values
   and convert them to fixed point representation. By default, each ROM has
   only nine values to feed the convolutional units.

   :param clk: clock signal
   :type clk: std_logic
   :param q: the concatenated output values of the ROM
   :type q: std_logic_vector

   .. method:: get_signals(self)



   .. method:: rtl(self, clk, q_bn, q_ssi)




.. py:class:: KernelROM(weights=[], **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class implements some functions to read the weights file and generate
   a ROM with the values identifyied by the layer_id, channel_id and unit_id.
   The clock signal serves only to give a signal to the sensitive list of the
   process, registers should not be generated.

   Both path to weights and data arrays about the weight organizations should
   be informed or implemented. The data to tiny_yolov3 first layer weights is
   informed in the __init__ method. To generate the kernel ROMs, this class
   provides some methods to read the weights, convert them to binary values
   and convert them to fixed point representation. By default, each ROM has
   only nine values to feed the convolutional units.

   :param clk: clock signal
   :type clk: std_logic
   :param q: the concatenated output values of the ROM
   :type q: std_logic_vector

   .. method:: get_signals(self)



   .. method:: rtl(self, clk, q)




.. py:class:: ConvLayer(size=3, channels=0, filters=0, binary=False, bin_input=False, bin_output=False, weights=[], **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class gather some MultiChannelConvUnits sharing the same inputs and
   makes your outputs availables to an external unit, probably a BufferLayer.
   The number MultiChannelConvUnits instantiated is this class is defined in
   the constants of the BaseComponent.

   :param filters: number of filters in this layer (outputs).
   :type filter: int
   :param channels: number of channels to be convolved (inputs)
   :type channels: int
   :param weights: array with weights to be distributed in conv units
   :type weights: List()
   :param binary: flag setting if will be used BinConvUnit or ConvUnit
   :type binary: bool
   :param bin_input: flag setting if the input is truncated to 1 bit
   :type bin_input: bool
   :param bin_output: flag setting if the output will be truncated to 1 bit
   :type bin_output: bool

   .. method:: rtl(self, clk, reset, input, output, en_mult, en_sum, en_channel, en_batch, en_act)


      This function implements the combinational and sequential blocks of
      this block.

      :param clk: clock signal
      :type clk: Signal()
      :param reset: reset signal
      :type reset: ResetSignal()
      :param en_mult: enable signal
      :type en_mult: Signal()
      :param en_sum: enable signal
      :type en_sum: Signal()
      :param en_channel: enable signal
      :type en_channel: Signal()
      :param en_batch: enable signal
      :type en_batch: Signal()
      :param en_act: enable signal
      :type en_act: Signal()
      :param input: vector with the nine input values concatenated, each value should be an signed value with 16 bits width
      :type input: Signal(intbv()[:])
      :param output: the output value of the convolutions
      :type output: Signal(intbv()[:])
      :return: logic of this block
      :rtype: @block method


   .. method:: get_signals(self)


      This function return the necessair signals to instantiate the rtl
      block and convert the python method to a vhdl file.

      :return: a dict specifying the input and outputs signals of the block.
      :rtype: dict of myhdl.Signal

      **Python definition of inputs and ouputs:**

      .. code-block:: python

          def get_signals(self):
              return {
                  "clk": Signal(False),
                  "reset": ResetSignal(0, active=1, isasync=1),
                  "input": Signal(intbv(0)[9*self.channels*16:]),
                  "output": Signal(intbv(0)[self.filters*16:]),
                  "en_mult": Signal(False),
                  "en_sum": Signal(False),
                  "en_channel": Signal(False),
                  "en_batch": Signal(False),
                  "en_act": Signal(False)
              }

      **VHDL component generated:**

      .. code-block:: vhdl

          component ConvLayer
              port (
                  clk        : in  std_logic;
                  reset      : in  std_logic;
                  input      : in  unsigned(9*self.channels*16 downto 0);
                  output     : out  unsigned(self.filters*16 downto 0);
                  en_mult    : in  std_logic;
                  en_sum     : in  std_logic;
                  en_channel : in  std_logic;
                  en_batch   : in  std_logic;
                  en_act     : in  std_logic
              );
          end component ConvLayer;



.. py:class:: MultiChannelConvUnit(channels=0, binary=False, bin_input=False, bin_output=False, weights=[], **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This block gather CHANNELS convolutional units receiveing CHANNEL bus
   inputs concatenated in one port, the same for the outputs. The kernel, bias
   and batch normalization values ​​are provided inside this unit for each
   convolutional unit input, except the control signs comes from a external
   control unit. Therefore, this constant values are updated to the
   convolutional units just in the right cicles. The same happens with the
   convolution units signs, so, the convolution units at principle runs
   synchronous with each other.

   The output port of this block is the result of the multichannel convolution
   operation with different kernel values and input channels. After the
   individual process of convolution between kernel values and input channels,
   the results are normalized and added with a bias value. Before the output
   be updated, the value pass in a leaky relu activation function.

   :param filters: number of filters in this layer (outputs).
   :type filter: int
   :param channels: number of channels to be convolved (inputs)
   :type channels: int
   :param weights: array with weights to be distributed in conv units
   :type weights: List()
   :param binary: flag setting if will be used BinConvUnit or ConvUnit
   :type binary: bool
   :param bin_input: flag setting if the input is be truncated to 1 bit
   :type bin_input: bool
   :param bin_output: flag setting if the output will be truncated to 1 bit
   :type bin_output: bool

   .. method:: get_signals(self)



   .. method:: rtl(self, clk, reset, input, output, en_mult, en_sum, en_channel, en_batch, en_act)


      :param clk: clock signal
      :type clk: std_logic
      :param reset: reset signal
      :type reset: std_logic
      :param en_mult: enable signal
      :type en_mult: std_logic
      :param en_sum: enable signal
      :type en_sum: std_logic
      :param input: vector with the nine input values cancatenated, each value         should be an signed value with 16 bits width
      :type input: std_logic_vector
      :param output: the output value of the convolutions
      :type output: unsigned



.. py:class:: BinConvUnit(bin_input=False, weights=[], **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class implements a block of binary convolutional unit used in this
   architecture. The block contains nine inputs from the input image channel,
   nine inputs from the kernel values, some control signals to the pipeline
   registers and an output representing a convolved pixel.

   The en_mult signal enables the multiplications with inputs and kernel
   values to be storaged in registers. The en_sum signal enables the calcule
   of the sums(organized in tree format) between the product of each calue
   calculated to be propagate to the outputs. The convolutions are maked using
   only the magnitude signal as in binary convolution networks.

   .. method:: rtl(self, clk, reset, en_mult, en_sum, input, output)


      This function implements the combinational and sequential blocks of
      this block.

      :param clk: clock signal
      :type clk: std_logic
      :param reset: reset signal
      :type reset: std_logic
      :param en_mult: enable signal
      :type en_mult: std_logic
      :param en_sum: enable signal
      :type en_sum: std_logic
      :param input: vector with the nine input values cancatenated, each value         should be an signed value with 16 bits width
      :type input: std_logic_vector
      :param output: the output value of the convolutions
      :type output: unsigned


   .. method:: get_signals(self)


      This function returns the signals necessairly to instantiate the rtl
      block and convert the python method to a vhdl file.

      :return: a dict specifying the input and outputs signals of the block.
      :rtype: dict of myhdl.Signal

      **Python definition of inputs and ouputs:**

      .. code-block:: python

          def get_signals(self):
              return {
                  "clk": Signal(False),
                  "reset": ResetSignal(0, active=1, isasync=1),
                  "en_mult": Signal(False),
                  "en_sum": Signal(False),
                  "input": Signal(intbv(0)[9*16:]),
                  "output": Signal(intbv(0)[16:])
              }

      **VHDL component generated:**

      .. code-block:: vhdl

          component BinConvUnit
              port (
                  clk: in std_logic;
                  reset: in std_logic;
                  en_mult: in std_logic;
                  en_sum: in std_logic;
                  input: in unsigned(143 downto 0);
                  output: out unsigned(15 downto 0)
              );
          end component BinConvUnit;



.. py:class:: ConvUnit(weights=[], **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class implements a block of convolutional unit used in this
   architecture. The block contains nine inputs from the input image channel,
   nine inputs from the kernel values, some control signals to the pipeline
   registers and an output representing a convolved pixel.

   The en_mult signal enables the multiplications with inputs and kernel
   values to be storaged in registers. The en_sum signal enables the calcule
   of the sums(organized in tree format) between the product of each calue
   calculated to be propagate to the outputs.

   :param weights: an array with the weights to be filled in KernelROM
   :type weights: List()

   .. method:: rtl(self, clk, reset, en_mult, en_sum, input, output)



   .. method:: get_signals(self)


      :param clk: clock signal
      :type clk: std_logic
      :param reset: reset signal
      :type reset: std_logic
      :param en_mult: enable signal
      :type en_mult: std_logic
      :param en_sum: enable signal
      :type en_sum: std_logic
      :param input: vector with the nine input values cancatenated, each value         should be an signed value with 16 bits width
      :type input: std_logic_vector
      :param output: the output value of the convolutions
      :type output: unsigned



.. py:class:: FixedPointMultiplier

   Bases: :class:`base_component.BaseComponent`

   This class implements a 16 bits fixed point Q5.11 multiplier. The main
   objective of this component is make able the use of registers inside the
   multipliers in the architecture. At first the multipliers offered by the
   FPGA device were potential critical paths as they are indivisible to the
   pipeline stages. Although not used yet, the reset and clk signals are here
   to make the implementation of the registers less painful.

   :param clk: clock signal
   :type clk: std_logic
   :param reset: reset signal
   :type reset: std_logic
   :param param_a: a value unsigned in fixed point representation
   :type param_a: unsigned (actually a signed value)
   :param param_b: other value unsigned in fixed point representation
   :type param_b: unsigned (actually a signed value)
   :param product: the result of parm_a and param_b multiplication in fixed     point representation.
   :type product: unsigned (actually a signed value)

   .. method:: concatenator(self, param_a, param_b, index, output)



   .. method:: rtl(self, clk, reset, param_a, param_b, product)



   .. method:: get_signals(self)




.. py:class:: MaxPoolLayer(filters=0, binary=False, **kwargs)

   Bases: :class:`base_component.BaseComponent`

   This class gather some MaxPoolUnits with different channel input and
   outputs. Both inputs are concatenated in one signal to the layer. The same
   to the outputs.

   :param filters: number of filters inputs to this layer
   :type filters: int

   .. method:: rtl(self, clk, reset, input, output, en_pool)


      This function implements the combinational and sequential blocks of
      this block.

      :param clk: clock signal
      :type clk: Signal()
      :param reset: reset signal
      :type reset: Signal()
      :param en_pool: enable signal
      :type en_pool: Signal()
      :param input: vector with the all channel inputs to the layer         concatenated, each channel input gather four input values         concatenated to form a input channel, each value should be an signed         value with 16 bits width
      :type input: Signal(intbv()[])
      :param output: the concatenated output values of the comparations
      :type output: Signal(intbv()[])

      :return: logic of this block
      :rtype: @block method


   .. method:: get_signals(self)


      This function returns the signals necessairly to instantiate the rtl
      block and convert the python method to a vhdl file.

      :return: a dict specifying the input and outputs signals of the block.
      :rtype: dict of myhdl.Signal

      **Python definition of inputs and ouputs:**

      .. code-block:: python

          def get_signals(self):
              return {
                  "clk": Signal(False),
                  "reset": ResetSignal(0, active=1, isasync=1),
                  "input": Signal(intbv(0)[4*self.filters*self.PORT_WIDTH:]),
                  "output": Signal(intbv(0)[self.filters*self.PORT_WIDTH:]),
                  "en_pool": Signal(False),
              }

      **VHDL component generated:**

      .. code-block:: vhdl

          component MaxPoolLayer
              port (
                  clk     : in  std_logic;
                  reset   : in  std_logic;
                  input   : in  unsigned(1023 downto 0);
                  output  : out unsigned(255 downto 0);
                  en_pool : in  std_logic
              );
          end component MaxPoolLayer;



.. py:class:: MaxPoolUnit(**kwargs)

   Bases: :class:`base_component.BaseComponent`

   This block describes a max pooling unit. Four inputs feeds three
   comparators organized in tree format. The output of this block is the input
   value with the greater value. The en_pool signal enables the output
   register to be stored.

   :param clk: clock signal
   :type clk: std_logic
   :param reset: reset signal
   :type reset: std_logic
   :param en_pool: enable signal
   :type en_pool: std_logic
   :param input: vector with the four input values cancatenated, each value     should be an signed value with 16 bits width
   :type input: std_logic_vector
   :param output: the output value of the comparations
   :type output: unsigned

   .. method:: rtl(self, clk, reset, en_pool, input, output)



   .. method:: get_signals(self)




.. py:class:: BinMaxPoolUnit(**kwargs)

   Bases: :class:`base_component.BaseComponent`

   This block describes a max pooling unit. Four inputs feeds three
   comparators organized in tree format. The output of this block is the input
   value with the greater value. The en_pool signal enables the output
   register to be stored.

   :param clk: clock signal
   :type clk: std_logic
   :param reset: reset signal
   :type reset: std_logic
   :param en_pool: enable signal
   :type en_pool: std_logic
   :param input: vector with the four input values cancatenated, each value     should be an signed value with 16 bits width
   :type input: std_logic_vector
   :param output: the output value of the comparations
   :type output: unsigned

   .. method:: rtl(self, clk, reset, en_pool, input, output)



   .. method:: get_signals(self)




.. py:class:: TriScatterUnit(input_size=0, **kwargs)

   Bases: :class:`components.base_component.BaseComponent`

   This block implements a unit to fill the inputs of a ConvUnit block. Nine
   outputs are provided for this cause. Four line buffers are implemented
   receiveing the outputs from the predecessor layer with four modes to read
   and write. The read and write mode define which line buffer will be used to
   write the outputs of the last layer. The three line buffers remaining are
   used to fill the registers outputs.

   :param input_size: size of the line_buffers of this unit.
   :type input_size: int

   .. method:: rtl(self, clk, reset, input_counter, input, output_counter, output, en_zero, mode, en_read, en_write)


      This function implements the combinational and sequential blocks of
      this block.

      :param clk: clock signal
      :type clk: std_logic
      :param reset: reset signal
      :type reset: std_logic
      :param en_zero: enable signal
      :type en_zero: std_logic
      :param en_read: enable signal
      :type en_read: std_logic
      :param input: vector with the input value with 16 bits width
      :type input: std_logic_vector
      :param output: the nine output values of the concatenated
      :type output: std_logic_vector
      :return: the logic implemented in this block
      :rtype: a method with @block decorator


   .. method:: get_signals(self)


      This function returns the signals necessairly to instantiate the rtl
      block and convert the python method to a vhdl file.

      :return: a dict specifying the input and output signals of the block.
      :rtype: dict of myhdl.Signal

      **Python definition of inputs and ouputs:**

      .. code-block:: python

          def get_signals(self):
              return {
                  "clk": Signal(False),
                  "reset": ResetSignal(0, active=1, isasync=1),
                  "input": Signal(intbv(0)[16:]),
                  "input_counter": Signal(intbv(0)[self.counter_size:]),
                  "output": Signal(intbv(0)[self.n_outputs*16:]),
                  "output_counter": Signal(intbv(0)
                                           [self.size*self.counter_size:]),
                  "en_zero": Signal(False),
                  "mode": Signal(intbv(0)[self.size+1:]),
                  "en_read": Signal(False),
                  "en_write": Signal(False)
              }

      **VHDL component generated:**

      .. code-block:: vhdl

          component TriScatterUnit is
              port (
                  clk            : in  std_logic;
                  reset          : in  std_logic;
                  en_zero        : in  std_logic;
                  en_read        : in  std_logic;
                  en_write       : in  std_logic;
                  mode           : in  unsigned(3 downto 0);
                  input_counter  : in  unsigned(8 downto 0);
                  input          : in  unsigned(15 downto 0);
                  output_counter : in  unsigned(26 downto 0);
                  output         : out unsigned(143 downto 0)
              );
          end component TriScatterUnit;



.. py:class:: NetworkParser(network_file='')

   .. method:: __parse_layer(self, layer, filters, channels)



   .. method:: __parse_conv_layer(self, layer, filters, channels)



   .. method:: __parse_max_pool_layer(self, layer, filters, channels)



   .. method:: parse_network(self)



   .. method:: generate(self)




.. function:: read_floats(file_path='', start=0, final=0)

   This function reads the file passed by the parameters and return the
   float list of values readed in the file.


.. function:: convert_fixed(weights=[])

   This funtion receives a list of weights and convert each one of the
   values to fixed point representation. By default, the decimal portion
   of the values are represented with 11 bits while the int portion is
   represented with 4 bits. One bit is reserved to the magnitude
   representation, totalizing 16 bits of fixed point representation.


